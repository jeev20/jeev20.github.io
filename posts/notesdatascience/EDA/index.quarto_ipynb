{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Exploratory data analysis \n",
        "description: \"Exploring data using univariate, bivariate and multivariate analysis\"\n",
        "author: \"Jeevith Hegde\"\n",
        "date: 2025-08-09 12:02 +0200\n",
        "format: \n",
        "    html\n",
        "toc: true\n",
        "lang: en\n",
        "jupyter: python3\n",
        "ipynb-shell-interactivity: all\n",
        "execute:\n",
        "  echo: false\n",
        "categories: [\"datascience\", \"fundamentals\"]\n",
        "tags: [\"notes\", \"eda\"]\n",
        "\n",
        "comments:\n",
        "  giscus:\n",
        "    repo: jeev20/jeev20.github.io\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# What is in my data? \n",
        "\n",
        "\n",
        "According to [Campusx-YouTube](https://youtu.be/mJlRTUuVr04?si=RCSLJGWOIAnQZhvW) these are some of the suggested questions to answer when a new dataset is obtained.\n",
        "```{mermaid}\n",
        "mindmap\n",
        "  root((Quick Data Exploration))\n",
        "    1 - How big is the data? \n",
        "    2 - How does the data look like?\n",
        "    3 - What type of datatypes are found in the data?\n",
        "    4 - Are there missing data in this dataset?\n",
        "    5 - How does the data look mathematically?\n",
        "    6 - Are there duplicate rows in this data?\n",
        "    7 - What is the correlation between the columns in this data?\n",
        "            \n",
        "```\n",
        "\n",
        "## Importing modules"
      ],
      "id": "30a95b12"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "import duckdb\n",
        "import polars as pl\n",
        "import seaborn as sn\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt"
      ],
      "id": "45af6002",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Reading data"
      ],
      "id": "4ca5d8d1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "# ts is in epoch time format so converting it to timestamp\n",
        "# rounding values for temperature and humidity\n",
        "# converting temperature from farhaneit to celsius\n",
        "\n",
        "input_data_path = f\"../data/iot/iot_telemetry_data.parquet\"\n",
        "\n",
        "\n",
        "df_raw = duckdb.sql(\n",
        "    f\"SELECT ts, to_timestamp(ts) AS timestamp, device, temp,ROUND((temp - 32) * 5.0 / 9, 4) AS temp_c, ROUND(humidity, 4) AS humidity, lpg, smoke, light FROM '{input_data_path}'\"\n",
        ")"
      ],
      "id": "75996dcb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exploring the data\n",
        "The seven questions to get insight into the data \n",
        "\n",
        "### How big is the data? "
      ],
      "id": "e7a33f5e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "# Converting to polars to easy statistics and exploration\n",
        "df_pl = df_raw.pl()  \n",
        "df_pl.shape"
      ],
      "id": "ddb2ff54",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### How does the data look like?"
      ],
      "id": "daa0c8cc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "df_pl.head()"
      ],
      "id": "67a02887",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### What type of datatypes are found in the data?"
      ],
      "id": "218b18df"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "duckdb.sql(\"SUMMARIZE df_raw;\")"
      ],
      "id": "4d5f614f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Are there missing data in this dataset?\n",
        "This dataset is quiet clean, there are no missing data in the input data in any feature. [Docs Reference](https://docs.pola.rs/user-guide/expressions/missing-data/)"
      ],
      "id": "cceb875d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "df_pl.null_count()"
      ],
      "id": "010f3dcd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### How does the data look mathematically?"
      ],
      "id": "89f9bb2a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "df_pl.describe()"
      ],
      "id": "031fa5f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Are there duplicate rows in this data?\n",
        "Although the below script shows there are duplicates, it looks like polars and pandas work differently here so it is important to check both. While polars returns all occurances of the duplicate, pandas only gets the duplicated values. Hence polars shows the shape to be `(26,8)` while pandas returns `13` duplicated rows in [this dataset](https://www.kaggle.com/datasets/garystafford/environmental-sensor-data-132k)"
      ],
      "id": "a772fe59"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "dup_mask = df_pl.is_duplicated()\n",
        "duplicates = df_pl.filter(dup_mask)  # Filter to show duplicated rows only\n",
        "\n",
        "df_pd = df_pl.to_pandas().duplicated().sum() # from pandas\n",
        "df_pd\n",
        "duplicates  # from polars"
      ],
      "id": "2642555f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### What is the correlation between the columns in this data?\n",
        "\n",
        "We need to use pandas here as the `.corr()` function in pandas provides a more readable table for inspecting correlation"
      ],
      "id": "dee7a9b5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "# Select only numeric columns for the correlation matrix\n",
        "numeric_df = df_pl.select(pl.col(pl.Float64 or pl.Int64)) \n",
        "numeric_df.to_pandas().corr(method='pearson')\n",
        "numeric_df.to_pandas().corr(method='spearman')\n",
        "numeric_df.to_pandas().corr(method='kendall')"
      ],
      "id": "0683df3b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Exploratory data analysis (EDA)\n",
        "\n",
        "```{mermaid}\n",
        "mindmap\n",
        "  root((EDA))\n",
        "    **Univariate data analysis** <br>Independent analysis of individual columns of the dataset. \n",
        "    **Bivariate data analysis** <br> Pairwise analysis of two columns of the dataset. \n",
        "    **Multivariate data analysis**<br> Simultaneously analysis of two or more columns.\n",
        "            \n",
        "```\n",
        "\n",
        "\n",
        "## Univariate data analysis\n",
        "### Handling categorial data\n",
        "\n",
        "#### Countplot\n",
        "Count plots provide the unique values of the column and their frequency of occurance. This provides a understanding on how the data is spread across the classes / categories of the"
      ],
      "id": "93fe4220"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.countplot(df_pl.select(pl.col('device')), x='device')"
      ],
      "id": "c4f687a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### PieChart\n",
        "A PieChart can be customized to show both the count of categories and their percentages in the dataset. "
      ],
      "id": "9aa95d25"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "vc = df_pl.to_pandas()['device'].value_counts()\n",
        "vc.plot(kind='pie', autopct=lambda pct: f'{int(round(pct * vc.sum() / 100))}\\n({pct:.1f}%)')"
      ],
      "id": "10732191",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Handling numerical data\n",
        "\n",
        "#### Histogram\n",
        "Histogram is a way to visualize a frequency table. The datapoints can be binned to `n` number of bins. "
      ],
      "id": "4ef96168"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.histplot(df_pl, x='humidity', bins=60)"
      ],
      "id": "c68af32c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.histplot(df_pl, x='temp_c', bins=60)"
      ],
      "id": "50cb3370",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Distplot\n",
        "Density plots show the distribution of the data values as a continuous line. It is a smoothed version of a histogram and is calculated via a `kernel density estimate` (page 24 - Practical Statistics for Data Scientists). The main difference between an histogram and a distplot is the `y-axis` scale. Displot uses probability scale and histogram uses frequency / count of observations. \n"
      ],
      "id": "7ea3324b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.displot(df_pl, x='humidity', kind=\"kde\")"
      ],
      "id": "ab8e41ea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.displot(df_pl, x='temp_c', kind=\"kde\")"
      ],
      "id": "0a88d5ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "But remember our data has three different sensors. Would be great to ensure we can see the probablity density function of each one seperately. But this will fall in Bivariate data analysis, as we are using another column to make sense of the `humidity` or `temp_c` column."
      ],
      "id": "281b42c8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.kdeplot(df_pl, x='humidity', hue='device')"
      ],
      "id": "1276a061",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Boxplot \n",
        "Boxplot give a quick way to visualize the distribution of data and provide boundaries to the observation outside which we find the `outliers`. It also shows the `25th percentile`, `median`, `75th percentile`. \n",
        "\n",
        "The visual also helps quickly notice the outliers in the observations on both lower and higher boundries. \n",
        "\n",
        "This is also called as a `5 point summary` visual.\n",
        "\n",
        "![BoxplotVisualized](images/Boxplot.jpg)"
      ],
      "id": "e2b28d0b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.boxplot(df_pl, x='humidity')"
      ],
      "id": "a020c535",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.boxplot(df_pl, x='temp_c')"
      ],
      "id": "c7811d9d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Bivariate data analysis\n",
        "### Scatterplot (Numerical to Numerical)"
      ],
      "id": "5f98793a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.scatterplot(df_pl, x='temp_c', y='humidity' )"
      ],
      "id": "9702f791",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Barplot (Numerical to categorical)"
      ],
      "id": "feb0d605"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.barplot(df_pl, x='temp_c', y='device')"
      ],
      "id": "37f8156d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Boxplot (Numerical to categorical)"
      ],
      "id": "158265fc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.boxplot(df_pl, x='temp_c', y='device')"
      ],
      "id": "d3bc0a19",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Multivariate data analysis\n"
      ],
      "id": "17391309"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sn.scatterplot(df_pl, x='temp_c', y='humidity', hue='device' )"
      ],
      "id": "d104781b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "\n",
        "# Convert Polars DataFrame to pandas for seaborn plotting\n",
        "df = df_pl.to_pandas()\n",
        "\n",
        "# Get unique devices (you want 3 scatterplots, one for each device)\n",
        "devices = df['device'].unique()\n",
        "\n",
        "# Create a figure with 1 row and 3 columns for side-by-side plots\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5), sharex=True, sharey=True)\n",
        "\n",
        "# Loop through devices and axes to plot each device's scatterplot\n",
        "for ax, device in zip(axes, devices):\n",
        "    subset = df[df['device'] == device]\n",
        "    sn.scatterplot(data=subset, x='temp_c', y='humidity', ax=ax)\n",
        "    ax.set_title(f'Device: {device}')\n",
        "    ax.set_xlabel('Temperature (Â°C)')\n",
        "    ax.set_ylabel('Humidity')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "cf726809",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Automated EDA using pandas-profiling\n",
        "This is a quick way to perform EDA and study the data. However, this only works on pandas dataframe. So if we have very large datasets, this approach may or may not be performant. \n",
        "\n",
        "That said, this approach eliminates most of the hassle in understanding the input data. \n",
        "\n",
        "It lacks in some visualization, which need to be performed to get a better idea of the data. "
      ],
      "id": "e04359e6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from ydata_profiling import ProfileReport\n",
        "profile = ProfileReport(df_pl.to_pandas(), title=\"Data Profiling Report\")\n",
        "profile.to_notebook_iframe()"
      ],
      "id": "8274c96d",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/wslap/Documents/jeev20.github.io/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}