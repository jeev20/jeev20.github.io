{
  "hash": "f461dd548c0fdc6a563443370f90f6cb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Update python project in an airgapped machine\ndescription: Shows how a python project can be updated in an airgapped machine\nauthor: \"Jeevith Hegde\"\ndate: 2025-07-04 22:25 +0200\nformat: html\ntoc: true\nlang: en\njupyter: python3\nipynb-shell-interactivity: all\nexecute:\n  echo: false\ncategories: [\"python\"]\ntags: [\"uv\", \"pip\"]\ncomments:\n  giscus:\n    repo: jeev20/jeev20.github.io\n---\n\n\n\n:::{.callout}\n**Scenario**\n\nUpdating production python code in an airgapped machine with a different python version and without access to uv. \n\n*How do we update the project in production?*\n:::\n\n## In the development machine\n\nTest that your python script works as expected. Follow the below steps when you want to update the source in airgapped machine. \n\n```{.bash}\nuv sync\n```\n\n`uv sync` ensures that the dependencies are correctly installed to a local virtual enviornment. \n\nWe will also need to save all the dependencies to a `requirements.txt` file as we do not have UV installed in the airgapped machine. \n\n```{.bash}\nuv pip freeze > requirements.txt\n```\n\nSometimes the `requirements.txt` needs to be double checked in this case uv insert an -e file line, which pip does not understand in the airgapped machine. \n\n\n\nThe below bash script was modified by Microsoft Copilot. This allows us to download all the requirements locally such that we can use them in the airgapped system. We ask pip to download the dependency for 3.12.3 python version as it is the python version in the airgapped machine. \n\nThis script will take a while to download all relevant wheels. \n```{.bash}\nmkdir -p offline_packages\n\nwhile IFS= read -r package || [ -n \"$package\" ]; do\n  case \"$package\" in\n    ''|\\#*) continue ;;  # Skip empty lines and comments\n  esac\n  echo \"Downloading $package for Python 3.12...\"\n  pip download \"$package\" \\\n    --python-version 3.12.3 \\\n    --platform manylinux2014_x86_64 \\\n    --only-binary=:all: \\\n    --implementation cp \\\n    --abi cp312 \\\n    -d offline_packages/\ndone < requirements.txt \n```\n\n\nNow we move the `whl` files to the airgapped machine. Secure copy (`scp`) allows us to send files and folders to airgapped machine without any issues. If the project folder is in the root folder, it is important that you have `sudo` access to the machine. \n\nSince the project folder contains the `offline_packages` folder and the `requirements.txt`, we can move the entire project folder. \n\n```{.bash}\nsudo scp -r YOURDEVPROJECTFOLDER/   USER@SERVER:/home/PATHTOPROJECT\n```\n\n\n## In the airgapped machine\n\nNavigate to the project folder and remove old virtual enviornment (folder) \n\n```{.bash}\nrm -r THEVIRTUALENVIRONMENTFOLDER\n```\n\nThis creates a new virtual enviornment and activates it. Ensure you have `virtualenv` installed.\n\n```{.bash}\nvirtualenv env && source env/bin/activate\n```\n\nWe add all the required packages to the virtual env. Here we tell pip where to look for packages (`offline_packages` folder)\n\n```{.bash}\npip install --no-index --find-links=offline_packages/ -r requirements.txt\n```\nThis way pip knows that all the required packages can be found in the `offline_packages` folder.\n\n\nNow we test the if the virtual enviornment i correctly installed and all project dependencies are added. Since we do not have `uv` in the airgapped machine. We use \n\n```{.bash}\npython3 src/OURSCRIPT.py\n```\nHurray! The scipt should now work as it does in the dev machine.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}